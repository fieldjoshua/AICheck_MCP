#!/bin/bash
# AICheck Module Development Kit (MDK)
# Tool for creating new modules with proper structure and best practices

# Load dependencies
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../ui/colors.sh"
source "$SCRIPT_DIR/../ui/output.sh"

function show_mdk_help() {
    print_header "AICheck Module Development Kit"
    echo ""
    print_section "What is MDK?"
    echo "The Module Development Kit helps you create new AICheck modules with:"
    echo "  • Proper file structure and naming"
    echo "  • Boilerplate code with best practices"
    echo "  • Automatic dependency management"
    echo "  • Integration with the dispatcher"
    echo "  • Built-in documentation"
    echo ""
    print_section "Usage:"
    print_command "./aicheck create-module <category>/<name>"
    echo ""
    print_section "Categories:"
    echo "  • ui         - User interface (colors, formatting)"
    echo "  • core       - Core functionality (state, errors)"
    echo "  • validation - Input/data validation"
    echo "  • actions    - Action management"
    echo "  • git        - Git operations"
    echo "  • deployment - Deployment tools"
    echo "  • analytics  - Usage tracking and metrics"
    echo "  • tools      - Development utilities"
    echo ""
    print_section "Examples:"
    print_command "./aicheck create-module analytics/metrics.sh"
    print_command "./aicheck create-module validation/config.sh"
    print_command "./aicheck create-module tools/backup.sh"
}

function create_module() {
    local module_path=$1
    
    if [ -z "$module_path" ]; then
        show_mdk_help
        return 1
    fi
    
    # Parse category and name
    local category=$(dirname "$module_path")
    local module_name=$(basename "$module_path")
    
    # Ensure .sh extension
    if [[ ! "$module_name" =~ \.sh$ ]]; then
        module_name="${module_name}.sh"
    fi
    
    # Full path
    local full_path="aicheck-lib/$category/$module_name"
    
    # Check if already exists
    if [ -f "$full_path" ]; then
        print_error "Module already exists: $full_path"
        return 1
    fi
    
    # Create directory if needed
    mkdir -p "aicheck-lib/$category"
    
    print_section "Creating module: $category/$module_name"
    
    # Determine module type and dependencies
    local dependencies=""
    local template_type="generic"
    
    case "$category" in
        "ui")
            dependencies="colors"
            template_type="ui"
            ;;
        "core")
            dependencies="errors output"
            template_type="core"
            ;;
        "validation")
            dependencies="errors output"
            template_type="validation"
            ;;
        "actions"|"git"|"deployment")
            dependencies="errors output state"
            template_type="feature"
            ;;
        "analytics"|"tools")
            dependencies="errors output"
            template_type="utility"
            ;;
    esac
    
    # Generate module content
    print_info "Generating module with template: $template_type"
    
    cat > "$full_path" << EOF
#!/bin/bash
# AICheck ${category^} Module: ${module_name%.sh}
# Generated by Module Development Kit
# Created: $(date +%Y-%m-%d)

# Module metadata
MODULE_NAME="${module_name%.sh}"
MODULE_VERSION="1.0.0"
MODULE_CATEGORY="$category"

# Load dependencies
EOF
    
    # Add dependency sources
    for dep in $dependencies; do
        case "$dep" in
            "colors")
                echo 'source "$(dirname "${BASH_SOURCE[0]}")/../ui/colors.sh"' >> "$full_path"
                ;;
            "output")
                echo 'source "$(dirname "${BASH_SOURCE[0]}")/../ui/output.sh"' >> "$full_path"
                ;;
            "errors")
                echo 'source "$(dirname "${BASH_SOURCE[0]}")/../core/errors.sh"' >> "$full_path"
                ;;
            "state")
                echo 'source "$(dirname "${BASH_SOURCE[0]}")/../core/state.sh"' >> "$full_path"
                ;;
        esac
    done
    
    echo "" >> "$full_path"
    
    # Add template-specific content
    case "$template_type" in
        "ui")
            cat >> "$full_path" << 'EOF'
# UI module for display and formatting

# Example function: format something
function format_example() {
    local text=$1
    echo -e "${GREEN}$text${NC}"
}

# Example: print styled message
function print_example() {
    local message=$1
    print_header "Example: $message"
}
EOF
            ;;
            
        "validation")
            cat >> "$full_path" << 'EOF'
# Validation module for input checking

# Example validation function
function validate_example() {
    local input=$1
    
    # Check if input is empty
    if [ -z "$input" ]; then
        error_exit "Input cannot be empty" $ERR_INVALID_INPUT
    fi
    
    # Add more validation logic here
    return 0
}

# Example: validate format
function validate_example_format() {
    local value=$1
    local pattern=$2
    
    if [[ ! "$value" =~ $pattern ]]; then
        return 1
    fi
    
    return 0
}
EOF
            ;;
            
        "core")
            cat >> "$full_path" << 'EOF'
# Core functionality module

# Initialize module
function init_module() {
    # Initialization logic here
    return 0
}

# Main functionality
function example_core_function() {
    local param=$1
    
    # Core logic here
    print_info "Processing: $param"
    
    return 0
}

# Cleanup function
function cleanup_module() {
    # Cleanup logic here
    return 0
}
EOF
            ;;
            
        "feature")
            cat >> "$full_path" << 'EOF'
# Feature module

# Main feature function
function main_feature() {
    local action=$1
    shift
    local args=("$@")
    
    case "$action" in
        "start")
            start_feature "${args[@]}"
            ;;
        "stop")
            stop_feature "${args[@]}"
            ;;
        "status")
            show_feature_status
            ;;
        *)
            print_error "Unknown action: $action"
            return 1
            ;;
    esac
}

# Start the feature
function start_feature() {
    print_section "Starting feature..."
    # Implementation here
    print_success "Feature started"
}

# Stop the feature
function stop_feature() {
    print_section "Stopping feature..."
    # Implementation here
    print_success "Feature stopped"
}

# Show status
function show_feature_status() {
    print_section "Feature Status"
    # Implementation here
}
EOF
            ;;
            
        *)  # generic/utility
            cat >> "$full_path" << 'EOF'
# Utility module

# Example utility function
function utility_example() {
    local input=$1
    
    # Process input
    local result=$(echo "$input" | tr '[:lower:]' '[:upper:]')
    
    echo "$result"
}

# Helper function
function helper_example() {
    local param=${1:-"default"}
    
    print_info "Helper called with: $param"
    
    return 0
}
EOF
            ;;
    esac
    
    # Add common footer
    cat >> "$full_path" << 'EOF'

# Module self-test (optional)
function test_module() {
    print_section "Testing $MODULE_NAME module"
    
    # Add test logic here
    print_success "Module tests passed"
    
    return 0
}

# Run tests if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    test_module
fi
EOF
    
    # Make executable
    chmod +x "$full_path"
    
    print_success "Module created: $full_path"
    
    # Update dispatcher if in path
    if prompt_user "Add to dispatcher loader?" "y" | grep -qi "^y"; then
        add_to_dispatcher "$category" "$module_name"
    fi
    
    # Show next steps
    echo ""
    print_section "Next Steps:"
    echo "1. Edit your module: $full_path"
    echo "2. Implement the functions you need"
    echo "3. Test your module: bash $full_path"
    echo "4. Integrate with AICheck commands"
    
    # Generate initial documentation
    generate_module_docs "$full_path"
}

# Add module to dispatcher
function add_to_dispatcher() {
    local category=$1
    local module_name=$2
    local dispatcher="aicheck-lib/core/dispatcher.sh"
    
    print_info "Adding to dispatcher..."
    
    # Find the right section in dispatcher
    local section_marker="# Features"
    case "$category" in
        "ui"|"core"|"validation")
            section_marker="# $category"
            ;;
    esac
    
    # Add source line (would need actual implementation)
    print_warning "Manual update needed in dispatcher.sh"
    print_command "source \"\$lib_dir/$category/$module_name\""
}

# Generate documentation
function generate_module_docs() {
    local module_path=$1
    local doc_path="${module_path%.sh}.md"
    
    print_info "Generating documentation..."
    
    # Extract module info
    local module_name=$(grep "^MODULE_NAME=" "$module_path" | cut -d'"' -f2)
    local module_version=$(grep "^MODULE_VERSION=" "$module_path" | cut -d'"' -f2)
    local functions=$(grep "^function " "$module_path" | awk '{print $2}' | cut -d'(' -f1)
    
    cat > "$doc_path" << EOF
# Module: $module_name

Version: $module_version
Path: $module_path

## Description

[Add module description here]

## Functions

EOF
    
    for func in $functions; do
        echo "### $func" >> "$doc_path"
        echo "" >> "$doc_path"
        echo "[Add function description]" >> "$doc_path"
        echo "" >> "$doc_path"
        echo '```bash' >> "$doc_path"
        echo "$func <args>" >> "$doc_path"
        echo '```' >> "$doc_path"
        echo "" >> "$doc_path"
    done
    
    print_success "Documentation created: $doc_path"
}

# Main entry point
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    create_module "$@"
fi